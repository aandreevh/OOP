Напишете шаблонен клас DynamicArray, който имплементира динамичен масив за тип T.

(+ бонус) Напишете шаблонент клас ArrayStack<T>, който наследява private/protected DynamicArray<T>

***
Напишете шаблонен клас Iterator<T>(bidirectional), който има следните методи:
Конструктори/Деструктори/Оператор= ( ако е нужно)
Т§ operator* / T& get() - връща текущ елемент
operator++ / Iterator& next() - мести пойнтъра на итератора напред
operator-- / Iterator& prev() - мести пойнтъра на итератора назад
bool hasNext() const - казва дали има следващ елемент
bool hasPrev() const - казва дали има предишен елемент
operator==/!= - сравнява 2 iterator посредством това дали те итерират върху една data
 и дали сочат към един и същ елемент
Допълнителна Функционалност


Напишете шаблонен клас Iterable<T>(bidirectional), който има следните методи:
Конструктори/Деструктори/Оператор= (ако е нужно)
Iterator<T> begin(); - връща итератор с пойнтър към началния елемент
Iterator<T> end(); - връща итератор с пойнтър към крайния елемент
Допълнителна функционалност

Наследете public Iterable<T> в клас DynamicArray<T> и напишете нужната функционалнст

Имайки предвид ограничеността ни, от страна на ООП, може да имплементирате Iterator,
така че да работи само с информация върху масиви.

+--------------------------------------------------------------------------+
|*****Вариант, който би работил без допълнително ООП(против ООП стандарите)|
|е да заобиколите ООП polymorphism-а, като подадете пойнтър на функция в   |
|конструктора на Iterator и така да дефинирате там как Iterator-a          |
|да се мести по контейнера. Това е по-скоро интересен похват, който се е   |
|използвал пред ООП да навлезе и чрез които се постига polymorphism на     |
|по-примитивно ниво.                                                       |
+--------------------------------------------------------------------------+


Целта ни е да постигнем следното нещо:


#define N 5

int main() {

    DynamicArray<int> arr(N);

    int counter=0;

    for(size_t i=0;i<N;i++)
        arr.insert(0,i); //0 - index

    for(auto i= arr.begin(); i != arr.end() ; ++i){
        *i = counter++;
        cout<<(*i);
    }

    return 0;
}

Извежда: 0123456789
